/*
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of the Contiki operating system.
 *
 */

#include "contiki.h"
#include "contiki-lib.h"
#include "contiki-net.h"

#include <string.h>

#include "config.h"
#define DEBUG 0
#ifndef DEBUG
#define DEBUG DEBUG_PRINT
#endif
#include "net/ip/uip-debug.h"

#include "debug.h"
#include "dtls.h"
#include "uip-ds6.h"

#define UIP_IP_BUF   ((struct uip_ip_hdr *)&uip_buf[UIP_LLH_LEN])
#define UIP_UDP_BUF  ((struct uip_udp_hdr *)&uip_buf[UIP_LLIPH_LEN])

#define MAX_PAYLOAD_LEN 120

static struct uip_udp_conn *server_conn;

static dtls_context_t *dtls_context;

#if ONLY_RESUMPTION
const unsigned char my_master_secret[] = {
//    0x86, 0xdc, 0xb3, 0x43, 0x44, 0xa1, 0x62, 0x55, 0x06, 0x2c, 0xe7, 0x89, 0x9c, 0x94, 0xdc, 0x14,
//    0x8d, 0x6f, 0xde, 0x66, 0x61, 0x26, 0xce, 0xd6, 0x5e, 0x95, 0x67, 0xaa, 0x82, 0xb4, 0x3e, 0xcc,
//    0x42, 0xb5, 0x95, 0x12, 0x4a, 0x85, 0xc7, 0xa5, 0xfb, 0xf2, 0xac, 0xda, 0x9f, 0x4c, 0x85, 0x02

      0x70, 0x17, 0xd4, 0x04, 0x80, 0xed, 0xe9, 0x22, 0x00, 0x49, 0xfe, 0xfd, 0xc0, 0xac, 0x00, 0x90,
      0xb3, 0x5e, 0x9a, 0x04, 0x17, 0x52, 0xcc, 0x65, 0xc4, 0x14, 0x16, 0xeb, 0xde, 0x00, 0x72, 0xca,
      0xc3, 0x40, 0x65, 0x4f, 0xd6, 0x2d, 0x96, 0x47, 0xde, 0x73, 0x57, 0xfa, 0xcd, 0xf1, 0xfb, 0xf9
};
const unsigned char peer_session_ticket[] = { /* peer's SessionTicket */
//    0x00, 0x01, 0x51, 0x80, 0x00, 0x69, 0xA3, 0x27, 0xA0, 0xBA, 0x59, 0x66, 0x1E, 0xE2, 0xE8, 0x84,
//    0x01, 0x77, 0xA6, 0x29, 0xE7, 0x7F, 0x94, 0x07, 0x3D, 0x82, 0x00, 0x49, 0x6F, 0x95, 0x91, 0x96,
//    0x8B, 0x6F, 0x57, 0x5A, 0xB2, 0xF9, 0x50, 0xDF, 0xCA, 0xBB, 0xB3, 0x5A, 0x18, 0xF4, 0x05, 0xB4,
//    0x9F, 0x64, 0xE4, 0x37, 0x97, 0xDC, 0xD7, 0x73, 0x49, 0xE3, 0x0A, 0xDA, 0x3B, 0xEA, 0x25, 0x56,
//    0x47, 0xAB, 0x3E, 0x7C, 0xE3, 0xF7, 0x74, 0x7A, 0x3A, 0x46, 0x6D, 0x11, 0x4B, 0xF7, 0xDD, 0xED,
//    0x89, 0xE9, 0x8B, 0xE9, 0xF1, 0xBB, 0xB2, 0xD1, 0xF6, 0xD8, 0xF1, 0xC9, 0x95, 0x3B, 0xD8, 0x2B,
//    0xD8, 0xE9, 0x8B, 0xCC, 0x2A, 0xCA, 0x97, 0xCA, 0x97, 0x6C, 0x11, 0x6C, 0x11
      0x00, 0x01, 0x51, 0x80, 0x00, 0x6A, 0xD3, 0x36, 0x10, 0xD2, 0x09, 0x81, 0x0E, 0xDF, 0x58, 0x56,
      0xB1, 0xC3, 0x96, 0x70, 0x17, 0xD4, 0x04, 0x80, 0xED, 0xE9, 0x22, 0x00, 0x49, 0xFE, 0xFD, 0xC0,
      0xAC, 0x00, 0x90, 0xB3, 0x5E, 0x9A, 0x04, 0x17, 0x52, 0xCC, 0x65, 0xC4, 0x14, 0x16, 0xEB, 0xDE,
      0x00, 0x72, 0x5F, 0xC8, 0x6E, 0x40, 0x5E, 0x6A, 0xB2, 0xD6, 0x7F, 0xCC, 0x5F, 0x05, 0x00, 0x24,
      0x9D, 0x33, 0xD8, 0xDD, 0x2D, 0x8D, 0x57, 0x85, 0x1F, 0x60, 0x2D, 0xE1, 0xDF, 0x2A, 0x5F, 0x89,
      0x24, 0x71, 0xB6, 0xBD, 0xE7, 0xD3, 0x79, 0xE9, 0x36, 0xE5, 0x07, 0x31, 0x9A, 0x64, 0x1E, 0x07,
      0x59, 0x08, 0xE5, 0x19, 0x2C, 0x75, 0xD2, 0x02, 0xD4, 0x22, 0x9F, 0x70, 0x73, 0x3D
};
#endif /* ONLY_RESUMPTION */

#if WITH_PKI
const unsigned char Server_Certificate[] = {
    0x4d, 0x49, 0x49, 0x42, 0x44, 0x6a, 0x43, 0x42, 0x74, 0x51, 0x49, 0x4a, 0x41, 0x49, 0x2b, 0x5a,
    0x6f, 0x6f, 0x33, 0x78, 0x41, 0x41, 0x52, 0x67, 0x4d, 0x41, 0x6b, 0x47, 0x42, 0x79, 0x71, 0x47,
    0x53, 0x4d, 0x34, 0x39, 0x42, 0x41, 0x45, 0x77, 0x44, 0x7a, 0x45, 0x4e, 0x4d, 0x41, 0x73, 0x47,
    0x41, 0x31, 0x55, 0x45, 0x41, 0x77, 0x77, 0x45, 0x55, 0x30, 0x6c, 0x44, 0x55, 0x7a, 0x41, 0x65,
    0x0a, 0x46, 0x77, 0x30, 0x78, 0x4d, 0x7a, 0x41, 0x78, 0x4d, 0x54, 0x45, 0x78, 0x4e, 0x6a, 0x41,
    0x35, 0x4e, 0x54, 0x56, 0x61, 0x46, 0x77, 0x30, 0x79, 0x4d, 0x7a, 0x41, 0x78, 0x4d, 0x44, 0x6b,
    0x78, 0x4e, 0x6a, 0x41, 0x35, 0x4e, 0x54, 0x56, 0x61, 0x4d, 0x42, 0x45, 0x78, 0x44, 0x7a, 0x41,
    0x4e, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x4d, 0x4d, 0x42, 0x6c, 0x4e, 0x6c, 0x63, 0x6e, 0x5a,
    0x6c, 0x0a, 0x63, 0x6a, 0x42, 0x5a, 0x4d, 0x42, 0x4d, 0x47, 0x42, 0x79, 0x71, 0x47, 0x53, 0x4d,
    0x34, 0x39, 0x41, 0x67, 0x45, 0x47, 0x43, 0x43, 0x71, 0x47, 0x53, 0x4d, 0x34, 0x39, 0x41, 0x77,
    0x45, 0x48, 0x41, 0x30, 0x49, 0x41, 0x42, 0x45, 0x65, 0x59, 0x55, 0x32, 0x72, 0x50, 0x52, 0x57,
    0x6c, 0x4e, 0x6e, 0x7a, 0x6e, 0x6b, 0x50, 0x68, 0x43, 0x2f, 0x6f, 0x6a, 0x61, 0x31, 0x2b, 0x39,
    0x57, 0x6b, 0x0a, 0x2b, 0x6b, 0x4b, 0x6d, 0x2b, 0x69, 0x72, 0x74, 0x50, 0x66, 0x39, 0x2b, 0x67,
    0x79, 0x66, 0x4c, 0x4f, 0x45, 0x46, 0x33, 0x73, 0x43, 0x37, 0x42, 0x7a, 0x6e, 0x66, 0x51, 0x65,
    0x78, 0x78, 0x4b, 0x68, 0x75, 0x45, 0x31, 0x48, 0x4e, 0x55, 0x74, 0x63, 0x43, 0x6c, 0x6d, 0x65,
    0x36, 0x6b, 0x32, 0x65, 0x78, 0x52, 0x71, 0x58, 0x53, 0x4a, 0x42, 0x34, 0x4e, 0x49, 0x77, 0x43,
    0x51, 0x59, 0x48, 0x0a, 0x4b, 0x6f, 0x5a, 0x49, 0x7a, 0x6a, 0x30, 0x45, 0x41, 0x51, 0x4e, 0x4a,
    0x41, 0x44, 0x42, 0x47, 0x41, 0x69, 0x45, 0x41, 0x35, 0x6d, 0x48, 0x6d, 0x39, 0x6d, 0x61, 0x6c,
    0x32, 0x6b, 0x67, 0x71, 0x75, 0x33, 0x6d, 0x76, 0x32, 0x62, 0x52, 0x4f, 0x6d, 0x68, 0x52, 0x36,
    0x39, 0x43, 0x35, 0x78, 0x52, 0x32, 0x68, 0x77, 0x56, 0x68, 0x56, 0x71, 0x4c, 0x4a, 0x79, 0x79,
    0x31, 0x67, 0x77, 0x43, 0x0a, 0x49, 0x51, 0x44, 0x6a, 0x6b, 0x4b, 0x38, 0x53, 0x38, 0x4f, 0x30,
    0x2b, 0x77, 0x41, 0x61, 0x52, 0x75, 0x4f, 0x6f, 0x6b, 0x61, 0x53, 0x67, 0x59, 0x73, 0x48, 0x35,
    0x4a, 0x4b, 0x51, 0x43, 0x43, 0x45, 0x58, 0x67, 0x6e, 0x33, 0x65, 0x76, 0x78, 0x79, 0x31, 0x7a,
    0x6b, 0x63, 0x77, 0x3d, 0x3d, 0x0a
};
#endif /* WITH_PKI */

int
read_from_peer(struct dtls_context_t *ctx, 
	       session_t *session, uint8 *data, size_t len) {
  size_t i;
  PRINTF("Reading from %u Bytes from peer: ", len);
  for (i = 0; i < len; i++)
    PRINTF("%c", data[i]);
  PRINTF("\n");

#if REBOOT_AFTER_HANDSHAKE
  printf("Reboot\n");
  SYS_REBOOT;
#endif /* REBOOT_AFTER_HANDSHAKE */
  /* echo incoming application data */
  /* dtls_write(ctx, session, data, len); */
  return 0;
}

int
send_to_peer(struct dtls_context_t *ctx, 
	     session_t *session, uint8 *data, size_t len) {

  struct uip_udp_conn *conn = (struct uip_udp_conn *)dtls_get_app_data(ctx);

  uip_ipaddr_copy(&conn->ripaddr, &session->addr);
  conn->rport = session->port;

  uip_udp_packet_send(conn, data, len);

  PRINTF("send to ");
  PRINT6ADDR(&conn->ripaddr);
  PRINTF(" %d\n", len);

  /* Restore server connection to allow data from any node */
  memset(&conn->ripaddr, 0, sizeof(server_conn->ripaddr));
  memset(&conn->rport, 0, sizeof(conn->rport));

  return len;
}

int
get_key(struct dtls_context_t *ctx, 
	const session_t *session, 
	const unsigned char *id, size_t id_len, 
	const dtls_key_t **result) {

#if WITH_PKI
  static const dtls_key_t pki = {
    .type = DTLS_KEY_PKI,
    /* public key identity (root CA) */
    .key.pki.id_pubkey = (unsigned char *) "SICS",
    /* public key identity length */
    .key.pki.id_pubkey_length = 4,
    /* public key key data */
    .key.pki.pubkey = (unsigned char *)
        "9BC63C75FC8235A39224132B99769961"
        "B0D3A8C477A2CC2581B5A260F636156B"
        "22E265E8B5B63653F1464C75A7874493"
        "3F84B60A4FBC96A53BFA291FE3D7C049",
    /* public key key data length */
    .key.pki.pubkey_length = 64,
    /* my private key */
    .key.pki.private_key = (unsigned char *)
        "76a6944c7f06f7f98dd749d6afcaad54"
        "d6d720c34171c5648adeb28ed3935850",
    /* length of my private key */
    .key.pki.private_key_length = 32,
    .key.pki.certificate_id = (unsigned char *) "Server",
    .key.pki.certificate_id_length = 6,
    /* my Certificate (does not contain comments) */
    .key.pki.certificate = Server_Certificate,
    /* length of my Certificate */
    .key.pki.certificate_length = sizeof(Server_Certificate)
  };
  *result = &pki;
#elif ONLY_RESUMPTION
  static const dtls_key_t abbr = {
      .type = DTLS_KEY_ABBR,
      /* peer's SessionTicket */
      .key.abbr.session_ticket = peer_session_ticket,
      .key.abbr.session_ticket_len = sizeof(peer_session_ticket),
      /* storing my own ticket */
      .key.abbr.my_session_ticket = my_master_secret,
      /* the secret to encrypt my SessionTicket */
      .key.abbr.ticket_secret = NULL,
      /* the name of the secret key */
      .key.abbr.ticket_secret_id = NULL,
      .key.abbr.id_pubkey = (unsigned char *) "SICS",
      .key.abbr.id_pubkey_length = 4,
      .key.abbr.certificate_id = (unsigned char *) "Server",
      .key.abbr.certificate_id_length = 6
  };
  *result = &abbr;
#else /* WITH_PKI */
  static const dtls_key_t psk = {
    .type = DTLS_KEY_PSK,
    .key.psk.id = (unsigned char *)"Client_identity", 
    .key.psk.id_length = 15,
    .key.psk.key = (unsigned char *)"secretPSK", 
    .key.psk.key_length = 9
  };

  *result = &psk;
#endif /* WITH_PKI */

  return 0;
}

PROCESS(udp_server_process, "UDP server process");
AUTOSTART_PROCESSES(&udp_server_process);
/*---------------------------------------------------------------------------*/
static void
dtls_handle_read(dtls_context_t *ctx) {
  session_t session;

  if(uip_newdata() && uip_datalen() > 1) {
    uip_ipaddr_copy(&session.addr, &UIP_IP_BUF->srcipaddr);
    session.port = UIP_UDP_BUF->srcport;
    session.size = sizeof(session.addr) + sizeof(session.port);
    
    PRINTF("Server received message from ");
    PRINT6ADDR(&session.addr);
    PRINTF(":%d uip_datalen %d\n", uip_ntohs(session.port),uip_datalen());

    dtls_handle_message(ctx, &session, uip_appdata, uip_datalen());
  }
}
/*---------------------------------------------------------------------------*/
static void
print_local_addresses(void)
{
  int i;
  uint8_t state;

  PRINTF("Server IPv6 addresses: ");
  for(i = 0; i < UIP_DS6_ADDR_NB; i++) {
    state = uip_ds6_if.addr_list[i].state;
    if(uip_ds6_if.addr_list[i].isused &&
       (state == ADDR_TENTATIVE || state == ADDR_PREFERRED)) {
      PRINT6ADDR(&uip_ds6_if.addr_list[i].ipaddr);
      PRINTF("\n");
    }
  }
}

void
init_dtls() {
  static dtls_handler_t cb = {
    .write = send_to_peer,
    .read  = read_from_peer,
    .event = NULL,
    .get_key = get_key
  };
#if UIP_CONF_ROUTER
  uip_ipaddr_t ipaddr;
#endif /* UIP_CONF_ROUTER */

  PRINTF("DTLS server started\n");

#if 0  /* TEST */
  memset(&tmp_addr, 0, sizeof(rimeaddr_t));
  if(get_eui64_from_eeprom(tmp_addr.u8));
#if UIP_CONF_IPV6
  memcpy(&uip_lladdr.addr, &tmp_addr.u8, 8);
#endif
#endif /* TEST */

//#if UIP_CONF_ROUTER
  uip_ip6addr(&ipaddr, 0xbbbb, 0, 0, 0, 0x0200, 0, 0, 2);
  //uip_ip6addr(&ipaddr, 0xaaaa, 0, 0, 0, 0, 0, 0, 0);
  uip_ds6_set_addr_iid(&ipaddr, &uip_lladdr);
  uip_ds6_addr_add(&ipaddr, 0, ADDR_AUTOCONF);
//#endif /* UIP_CONF_ROUTER */

  server_conn = udp_new(NULL, 0, NULL);
  udp_bind(server_conn, UIP_HTONS(20220));

  set_log_level(LOG_DEBUG);

  dtls_context = dtls_new_context(server_conn);
  if (dtls_context)
    dtls_set_handler(dtls_context, &cb);

#if STATIC_ROUTING
  /* static routing */
  uip_ipaddr_t ipaddr_nxh, ipaddr_dst;
  uip_ip6addr(&ipaddr_dst, 0xaaaa, 0, 0, 0, 0x0200, 0, 0, 0x0001);
  uip_ip6addr(&ipaddr_nxh, 0xfe80, 0, 0, 0, 0x0200, 0, 0, 0x0004);
  uip_lladdr_t lladdr;
  memcpy(&lladdr, ipaddr_nxh.u8[8], UIP_LLADDR_LEN);
  if(uip_ds6_nbr_add(&ipaddr_nxh, &lladdr, 1, NBR_REACHABLE) == NULL){
    printf("add nbr fail\n");
  }
  /* next hope for dest*/
  uip_ds6_route_add(&ipaddr_dst, 128, &ipaddr_nxh);
#endif /* STATIC_ROUTING */
}

/*---------------------------------------------------------------------------*/
PROCESS_THREAD(udp_server_process, ev, data)
{
  PROCESS_BEGIN();

  dtls_init();
  init_dtls();
  print_local_addresses();

  if (!dtls_context) {
    dsrv_log(LOG_EMERG, "cannot create context\n");
    PROCESS_EXIT();
  }

  while(1) {
    PROCESS_WAIT_EVENT();
    if(ev == tcpip_event) {
      dtls_handle_read(dtls_context);
    }
#if 0
    if (bytes_read > 0) {
      /* dtls_handle_message(dtls_context, &the_session, readbuf, bytes_read); */
      read_from_peer(dtls_context, &the_session, readbuf, bytes_read);
    }
    dtls_handle_message(ctx, &session, uip_appdata, bytes_read);
#endif
  }

  PROCESS_END();
}
/*---------------------------------------------------------------------------*/
